from collections import defaultdict
from itertools import count
from string import capwords

try:
    from . import Errors
    from .AST import *
    from .Tokens import ALIASES
except ImportError:
    from AST import *

class Scope:
    def __init__(self, name):
        self.name = name
        self.namespace = {}

    def __repr__(self):
        return f"<Scope '{self.name}'>"

class Transpiler:
    def __init__(self, tree, indent_size=3):
        self.tree = tree
        self.indent_size = indent_size
        self.indent_level = 0
        self.global_vars = {}
        self.player_vars = {}
        self.global_index = count()
        self.player_index = defaultdict(count)
        self.array_modify_index = 0
        self.line = 0
        self.functions = {}
        self.arrays = {}
        self.scopes = []
        self.aliases = {k: v for d in ALIASES.values() for k, v in d.items()}

    @property
    def tabs(self):
        return ' ' * self.indent_size * self.indent_level

    def clean(self, str_):
        return '('.join(capwords(s) for s in str_.split('('))

    def assign(self, node, value):
        code = ''
        name = node.name
        if type(node) == GlobalVar:
            index = self.global_vars.get(name)
            if index is None:
                index = next(self.global_index)
                self.global_vars[name] = index
            code += f'Set Global Variable At Index(A, {index}, '
        elif type(node) == PlayerVar:
            player = node.player
            index = self.player_vars.get((player, name))
            if index is None:
                index = next(self.player_index[player])
                self.player_vars[(player, name)] = index
            code += f'Set Player Variable At Index({player}, A, {index}, '
        code += self.visit(value) + ')'
        return code

    def lookup(self, node):
        name = node.name
        if type(node) == GlobalVar:
            index = self.global_vars.get(name)
            if index is None:
                index = self.global_vars[name] = next(self.global_index)
            return index
        elif type(node) == PlayerVar:
            index = self.player_vars.get((node.player, name))
            if index is None:
                index = self.player_vars[(player, name)] = next(self.player_index[player])
            return index

    def visitScript(self, node):
        code = r'rule("Generated by https://github.com/adapap/OWScript") { Event { Ongoing - Global; }}' + '\n'
        return code + self.visitChildren(node).rstrip('\n')

    def visitRule(self, node):
        code = 'rule(' + self.visit(node.name) + ') {\n' + self.visitChildren(node) + '}\n'
        return code

    def visitBlock(self, node):
        self.indent_level += 1
        code = self.visitChildren(node)
        self.indent_level -= 1
        return code

    def visitRuleblock(self, node):
        code = self.tabs + node.name + ' {\n'
        self.indent_level += 1
        for ruleblock in node.children:
            for line in ruleblock.children:
                code += self.tabs + self.visit(line) + ';\n'
        self.indent_level -= 1
        code += self.tabs + '}\n'
        return code

    def visitOWID(self, node):
        code = self.clean(self.aliases.get(node.name.upper(), node.name))
        if node.children:
            code += '('
            children = [self.visit(child) for child in node.children]
            code += ', '.join(children)
            code += ')'
        return code

    def visitCompare(self, node):
        code = self.visit(node.left) + f' {node.op} ' + self.visit(node.right)
        return code

    def visitAssign(self, node):
        code = ''
        value = node.right
        if type(node.right) == Array:
            self.arrays[node.left.name] = value
        value = {
            '+=': BinaryOp(left=node.left, op='+', right=value),
            '-=': BinaryOp(left=node.left, op='-', right=value),
            '*=': BinaryOp(left=node.left, op='*', right=value),
            '/=': BinaryOp(left=node.left, op='/', right=value),
            '^=': BinaryOp(left=node.left, op='^', right=value),
            '%=': BinaryOp(left=node.left, op='%', right=value)
        }.get(node.op, value)
        if type(node.left) == Item:
            item = node.left
            name = item.parent.name
            index = self.lookup(node=item.parent)
            try:
                array_index = int(self.visit(item.index))
            except ValueError:
                raise Errors.SyntaxError('Array modification index must be an integer')
            self.arrays[name][array_index] = value
            code += f'Set Global Variable(B, {self.visit(item.parent)});\n'
            if type(value) == Array:
                raise Errors.NotImplementedError('Array modification cannot be used for nested arrays')
            code += self.tabs + f'Set Global Variable At Index(B, {array_index}, {self.visit(value)});\n'
            code += self.tabs + f'Set Global Variable At Index(A, {index}, Global Variable(B))'
            return code
        else:
            name = node.left.name
        code += self.assign(node=node.left, value=value)
        return code

    def visitIf(self, node):
        cond = self.visit(node.cond)
        true_lines = len(node.true_block.children)
        if node.false_block:
            true_lines += 1
            if type(node.false_block) == If:
                false_lines = len(node.false_block.true_block.children) + 1
            else:
                false_lines = len(node.false_block.children)
        code = 'Skip If(Not(' + cond + '), ' + str(true_lines) + ');\n'
        for line in node.true_block.children:
            code += self.tabs + self.visit(line) + ';\n'
        if node.false_block:
            code += self.tabs + 'Skip(' + str(false_lines) + ');\n'
            if type(node.false_block) == If:
                code += self.tabs + self.visit(node.false_block)
            else:
                for line in node.false_block.children:
                    code += self.tabs + self.visit(line) + ';\n'
        return code.rstrip(';\n')

    def visitBinaryOp(self, node):
        code = {
            '+': 'Add',
            '-': 'Subtract',
            '*': 'Multiply',
            '/': 'Divide',
            '^': 'Raise To Power',
            '%': 'Modulo',
            'or': 'Or',
            'and': 'And'
        }.get(node.op)
        code += '(' + self.visit(node.left) + ', ' + self.visit(node.right) + ')'
        return code

    def visitUnaryOp(self, node):
        if node.op == '-':
            code = '-' + self.visit(node.right)
        elif node.op == 'not':
            code = 'Not(' + self.visit(node.right) + ')'
        return code

    def visitGlobalVar(self, node):
        index = self.lookup(node=node)
        return f'Value In Array(Global Variable(A), {index})'

    def visitPlayerVar(self, node):
        index = self.lookup(node=node)
        code = f'Value In Array(Player Variable(' + self.visit(node.player) + f', A), {index})'
        return code

    def visitString(self, node):
        return node.value

    def visitNumeral(self, node):
        return node.value

    def visitVector(self, node):
        code = 'Vector('
        components = ', '.join(self.visit(x) for x in node.children)
        code += components + ')'
        return code

    def visitArray(self, node):
        if not node.elements:
            code = 'Empty Array'
        else:
            num_elems = len(node.elements)
            code = 'Append To Array(' * num_elems
            code += 'Empty Array, ' + '), '.join(self.visit(elem) for elem in node.elements) + ')'
        return code

    def visitItem(self, node):
        return 'Value In Array(' + self.visit(node.parent) + ', ' + self.visit(node.index) + ')'

    def visitCall(self, node):
        callee = node.parent
        args = list(map(self.visit, node.args))
        code = ''
        if type(callee) == Attribute:
            method = callee.name
            if method == 'append':
                try:
                    assert len(args) == 1
                    value = node.args[0]
                    self.arrays[callee.parent.name].append(value)
                    index = self.lookup(callee.parent)
                    if type(callee.parent) == GlobalVar:
                        code += f'Modify Global Variable At Index(A, {index}, Append To Array, {value})'
                except AssertionError:
                    raise Errors.SyntaxError('push expected 1 parameter, received {}'.format(len(args)))
                except Exception as e:
                    print(e)
            else:
                raise SyntaxError("Unknown method '{}'".format(method))
        else:
            print('a real call!')
        return code

    def visit(self, node):
        method_name = 'visit' + type(node).__name__
        visitor = getattr(self, method_name)
        return visitor(node)

    def visitChildren(self, node):
        code = ''
        for child in node.children:
            code += self.visit(child)
        return code

    def run(self):
        return self.visit(self.tree)